---
- name: Check for docker-compose.yml
  ansible.builtin.stat:
    path: "/home/{{ app_user }}/app/docker-compose.yml"
  register: docker_compose_file
  become: yes
  become_user: "{{ app_user }}"

- name: Fail if docker-compose.yml not found
  ansible.builtin.fail:
    msg: "docker-compose.yml not found in the repository"
  when: not docker_compose_file.stat.exists

- name: Create systemd user directory
  ansible.builtin.file:
    path: "/home/{{ app_user }}/.config/systemd/user"
    state: directory
    mode: '0755'
  become: yes
  become_user: "{{ app_user }}"

- name: Install app systemd service
  ansible.builtin.template:
    src: app.service.j2
    dest: "/home/{{ app_user }}/.config/systemd/user/app.service"
    mode: '0644'
  become: yes
  become_user: "{{ app_user }}"
  notify: restart app service

- name: Pull Docker images (this may take a while)
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/bin/docker compose pull"
    chdir: "/home/{{ app_user }}/app"
  become: yes
  become_user: "{{ app_user }}"
  environment:
    DOCKER_HOST: "unix:///run/user/{{ app_user_uid.stdout }}/docker.sock"
    PATH: "/home/{{ app_user }}/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  async: 1800 # Allow up to 30 minutes for pulling images
  poll: 10    # Check status every 10 seconds

- name: Build Docker images (this may take a while)
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/bin/docker compose build"
    chdir: "/home/{{ app_user }}/app"
  become: yes
  become_user: "{{ app_user }}"
  environment:
    DOCKER_HOST: "unix:///run/user/{{ app_user_uid.stdout }}/docker.sock"
    PATH: "/home/{{ app_user }}/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  async: 1800 # Allow up to 30 minutes for building
  poll: 10

- name: Enable and start app service
  ansible.builtin.systemd:
    name: app.service
    scope: user
    enabled: yes
    state: started
    daemon_reload: yes
  become: yes
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ app_user_uid.stdout }}"
    DBUS_SESSION_BUS_ADDRESS: "unix:path=/run/user/{{ app_user_uid.stdout }}/bus"

- name: Wait briefly for service to initialize
  ansible.builtin.wait_for:
    timeout: 10

- name: Check service status
  ansible.builtin.command:
    cmd: "systemctl --user is-active app"
  register: service_status
  become: yes
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ app_user_uid.stdout }}"
    DBUS_SESSION_BUS_ADDRESS: "unix:path=/run/user/{{ app_user_uid.stdout }}/bus"
  ignore_errors: yes

- name: Fetch service logs on failure
  ansible.builtin.command:
    cmd: "journalctl --user -u app -n 50 --no-pager"
  register: service_logs
  become: yes
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ app_user_uid.stdout }}"
  when: service_status.rc != 0

- name: Fail with logs if service is not active
  ansible.builtin.fail:
    msg: |
      Service failed to start!
      Status: {{ service_status.stdout }}
      
      Recent Logs:
      {{ service_logs.stdout }}
  when: service_status.rc != 0

- name: Verify application is responding (Health Check)
  ansible.builtin.uri:
    url: "http://localhost:{{ app_port }}"
    status_code: [200, 301, 302, 307, 308, 401, 403, 404]
    return_content: no
  register: app_health_check
  until: app_health_check.status != -1
  retries: 80 # 20 minutes wait
  delay: 15
  become: yes
  become_user: "{{ app_user }}"
  failed_when: app_health_check.status == -1
  ignore_errors: yes

- name: Prune unused Docker objects
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/bin/docker system prune -f"
  become: yes
  become_user: "{{ app_user }}"
  environment:
    DOCKER_HOST: "unix:///run/user/{{ app_user_uid.stdout }}/docker.sock"

- name: Monitor Docker Compose service
  ansible.builtin.debug:
    msg: |
      Application deployed successfully!

      To view the service status:
      sudo -u {{ app_user }} XDG_RUNTIME_DIR=/run/user/{{ app_user_uid.stdout }} systemctl --user status app

      To follow the logs:
      sudo journalctl _UID={{ app_user_uid.stdout }} _SYSTEMD_USER_UNIT=app.service -f