---
- name: Check for docker-compose.yml
  ansible.builtin.stat:
    path: "/home/{{ app_user }}/app/docker-compose.yml"
  register: docker_compose_file
  become: yes
  become_user: "{{ app_user }}"

- name: Fail if docker-compose.yml not found
  ansible.builtin.fail:
    msg: "docker-compose.yml not found in the repository"
  when: not docker_compose_file.stat.exists

- name: Create systemd user directory
  ansible.builtin.file:
    path: "/home/{{ app_user }}/.config/systemd/user"
    state: directory
    mode: '0755'
  become: yes
  become_user: "{{ app_user }}"

- name: Install app systemd service
  ansible.builtin.template:
    src: app.service.j2
    dest: "/home/{{ app_user }}/.config/systemd/user/app.service"
    mode: '0644'
  become: yes
  become_user: "{{ app_user }}"
  notify: restart app service

- name: Pull Docker images (this may take a while)
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/bin/docker compose pull"
    chdir: "/home/{{ app_user }}/app"
  become: yes
  become_user: "{{ app_user }}"
  environment:
    DOCKER_HOST: "unix:///run/user/{{ app_user_uid.stdout }}/docker.sock"
    PATH: "/home/{{ app_user }}/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  async: 1800 # Allow up to 30 minutes for pulling images
  poll: 10    # Check status every 10 seconds

- name: Build Docker images (this may take a while)
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/bin/docker compose build"
    chdir: "/home/{{ app_user }}/app"
  become: yes
  become_user: "{{ app_user }}"
  environment:
    DOCKER_HOST: "unix:///run/user/{{ app_user_uid.stdout }}/docker.sock"
    PATH: "/home/{{ app_user }}/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  async: 1800 # Allow up to 30 minutes for building
  poll: 10

- name: Pre-check for failed containers to force restart
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/bin/docker compose ps -a --format json"
    chdir: "/home/{{ app_user }}/app"
  register: pre_check_containers
  become: yes
  become_user: "{{ app_user }}"
  environment:
    DOCKER_HOST: "unix:///run/user/{{ app_user_uid.stdout }}/docker.sock"
  changed_when: false
  ignore_errors: yes

- name: Stop app service if containers are in failed state
  ansible.builtin.systemd:
    name: app.service
    scope: user
    state: stopped
  become: yes
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ app_user_uid.stdout }}"
    DBUS_SESSION_BUS_ADDRESS: "unix:path=/run/user/{{ app_user_uid.stdout }}/bus"
  when: >
    pre_check_containers.rc is defined and pre_check_containers.rc == 0 and
    (pre_check_containers.stdout_lines | default([], true) | map('from_json') | selectattr('State', 'ne', 'running') | list | length > 0)

- name: Flush handlers to ensure restart happens before status check
  ansible.builtin.meta: flush_handlers

- name: Enable and start app service
  ansible.builtin.systemd:
    name: app.service
    scope: user
    enabled: yes
    state: started
    daemon_reload: yes
  become: yes
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ app_user_uid.stdout }}"
    DBUS_SESSION_BUS_ADDRESS: "unix:path=/run/user/{{ app_user_uid.stdout }}/bus"

- name: Wait for containers to start or fail (Fail Fast)
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/bin/docker compose ps -a --format json"
    chdir: "/home/{{ app_user }}/app"
  register: docker_startup_check
  become: yes
  become_user: "{{ app_user }}"
  environment:
    DOCKER_HOST: "unix:///run/user/{{ app_user_uid.stdout }}/docker.sock"
  changed_when: false
  until: >
    docker_startup_check.rc is defined and docker_startup_check.rc == 0 and
    (docker_startup_check.stdout_lines | default([], true) | length > 0) and
    (
      (docker_startup_check.stdout_lines | map('from_json') | selectattr('State', 'ne', 'running') | list | length == 0)
      or
      (docker_startup_check.stdout_lines | map('from_json') | selectattr('State', 'in', ['exited', 'dead']) | list | length > 0)
    )
  retries: 24 # Wait up to 2 minutes (24 * 5s)
  delay: 5
  failed_when: >
    docker_startup_check.rc is defined and docker_startup_check.rc != 0 or
    (docker_startup_check.stdout_lines | default([], true) | map('from_json') | selectattr('State', 'in', ['exited', 'dead']) | list | length > 0)
  ignore_errors: yes

- name: Parse container status on failure
  ansible.builtin.set_fact:
    non_running_containers: >-
      {{
        docker_startup_check.stdout_lines | default([], true) |
        map('from_json') |
        selectattr('State', 'ne', 'running') |
        list
      }}
  when: 
    - docker_startup_check.failed
    - docker_startup_check.rc is defined
    - docker_startup_check.rc == 0
- name: Fetch service logs on startup failure
  ansible.builtin.command:
    cmd: "journalctl _UID={{ app_user_uid.stdout }} _SYSTEMD_USER_UNIT=app.service -n 100 --no-pager"
  register: startup_failure_logs
  become: yes
  when: docker_startup_check.failed

- name: Display failure details
  ansible.builtin.debug:
    msg: "{{ failure_message.split('\n') }}"
  vars:
    failure_message: |
      Containers failed to start properly!
      
      Non-Running Containers:
      {% for container in non_running_containers %}
      - Name: {{ container.Name }}
        State: {{ container.State }}
        Exit Code: {{ container.ExitCode }}
        Status: {{ container.Status }}
      {% endfor %}
      
      Recent Service Logs:
      ---------------------------------------------------
      {{ startup_failure_logs.stdout }}
  when: docker_startup_check.failed

- name: Fail deployment
  ansible.builtin.fail:
    msg: "Deployment failed due to non-running containers. See above debug message for details."
  when: docker_startup_check.failed
- name: Verify application is responding (Health Check)
  ansible.builtin.uri:
    url: "http://localhost:{{ app_port }}"
    status_code: [200, 301, 302, 307, 308, 401, 403, 404]
    return_content: no
  register: app_health_check
  until: app_health_check.status != -1
  retries: 10 # 2.5 minutes wait
  delay: 15
  become: yes
  become_user: "{{ app_user }}"
  failed_when: app_health_check.status == -1
  ignore_errors: yes

- name: Fetch service logs on health check failure
  ansible.builtin.command:
    cmd: "journalctl --user -u app -n 50 --no-pager"
  register: health_check_logs
  become: yes
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ app_user_uid.stdout }}"
  when: app_health_check.failed

- name: Fail with logs if health check failed
  ansible.builtin.fail:
    msg: |
      Application health check failed! The application is not responding at http://localhost:{{ app_port }}

      Recent Logs:
      {{ health_check_logs.stdout }}
  when: app_health_check.failed

- name: Prune unused Docker objects
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/bin/docker system prune -f"
  become: yes
  become_user: "{{ app_user }}"
  environment:
    DOCKER_HOST: "unix:///run/user/{{ app_user_uid.stdout }}/docker.sock"

- name: Monitor Docker Compose service
  ansible.builtin.debug:
    msg: |
      Application deployed successfully!

      To view the service status:
      sudo -u {{ app_user }} XDG_RUNTIME_DIR=/run/user/{{ app_user_uid.stdout }} systemctl --user status app

      To follow the logs:
      sudo journalctl _UID={{ app_user_uid.stdout }} _SYSTEMD_USER_UNIT=app.service -f