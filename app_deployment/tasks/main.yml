---
# tasks file for app_deployment
- name: "Fail if app_repo is not set"
  ansible.builtin.fail:
    msg: "The 'app_repo' variable is set to the default placeholder 'your_app_repo.git'. Please provide a valid Git repository URL in app_deployment/vars/main.yml."
  when: app_repo == 'your_app_repo.git'
  run_once: true

- name: Ensure git is installed
  ansible.builtin.apt:
    name: git
    state: present
    update_cache: yes

- name: Check if the git repository is valid and accessible
  ansible.builtin.command:
    cmd: "git ls-remote {{ app_repo }}"
  register: git_check
  changed_when: false
  failed_when: false # We handle the failure manually
  run_once: true

- name: Fail if git repository is not accessible
  ansible.builtin.fail:
    msg: "The git repository '{{ app_repo }}' is not accessible. Please check the URL and access rights. Error: {{ git_check.stderr }}"
  when: git_check.rc != 0
  run_once: true

- name: Validate that APP_PORT is defined in app_ports
  ansible.builtin.fail:
    msg: "The 'app_ports' list in app_deployment/vars/main.yml must contain 'APP_PORT' for Nginx configuration."
  when: "'APP_PORT' not in app_ports"

- name: Set app_user fact
  ansible.builtin.set_fact:
    app_user: "{{ (app_repo | basename | regex_replace('.git$', ''))[:32] }}"

- name: Create a new system user for the application
  ansible.builtin.user:
    name: "{{ app_user }}"
    shell: /usr/sbin/nologin
    system: yes
    create_home: yes

- name: Ensure remote_tmp directory exists for app_user
  ansible.builtin.file:
    path: "/home/{{ app_user }}/.ansible/tmp"
    state: directory
    mode: '0755'
    owner: "{{ app_user }}"
    group: "{{ app_user }}"
  become: yes

- name: Set up rootless docker for app user
  ansible.builtin.include_tasks: rootless_docker.yml

- name: Find available ports for the application
  ansible.builtin.shell: |
    comm -23 <(seq 8080 8180 | sort) <(ss -Htan | awk '{print $4}' | awk -F':' '{print $NF}' | sort -u) | head -n {{ app_ports | length }}
  args:
    executable: /bin/bash
  register: next_available_ports
  changed_when: false

- name: Create a dictionary of found ports
  ansible.builtin.set_fact:
    found_ports: "{{ dict(app_ports | zip(next_available_ports.stdout_lines)) }}"

- name: Set app_port fact for Nginx
  ansible.builtin.set_fact:
    app_port: "{{ found_ports.APP_PORT }}"

- name: Display assigned ports
  ansible.builtin.debug:
    msg: "{{ my_message.split('\\n') }}"
  vars:
    my_message: |
      Application ports have been assigned as follows:
      {% for port_name, host_port in found_ports.items() %}
      Service {{ port_name | replace('_PORT', '') | lower | capitalize }} ({{ port_name }}) is accessible via VPN at {{ ansible_host }}:{{ host_port }}
      {% endfor %}

- name: Read apps.json
  ansible.builtin.slurp:
    src: /var/www/status/apps.json
  register: apps_json_content

- name: Update apps.json
  ansible.builtin.copy:
    content: "{{ apps_json_content.content | b64decode | from_json | combine({app_user: found_ports}) | to_json }}"
    dest: /var/www/status/apps.json
  when: apps_json_content.content is defined

- name: Create app directory
  ansible.builtin.file:
    path: "/home/{{ app_user }}/app"
    state: directory
    owner: "{{ app_user }}"
    group: "{{ app_user }}"
    mode: '0755'

- name: Clone the application repository
  ansible.builtin.git:
    repo: "{{ app_repo }}"
    dest: "/home/{{ app_user }}/app"
    accept_hostkey: yes
  become: yes
  become_user: "{{ app_user }}"

- name: Check for .env.example
  ansible.builtin.stat:
    path: "/home/{{ app_user }}/app/.env.example"
  register: env_example_file
  become: yes
  become_user: "{{ app_user }}"

- name: Read .env.example content
  ansible.builtin.slurp:
    src: "/home/{{ app_user }}/app/.env.example"
  register: env_example_content
  when: env_example_file.stat.exists
  become: yes
  become_user: "{{ app_user }}"

- name: Parse .env.example and prepare for prompting
  ansible.builtin.set_fact:
    env_vars_to_prompt: |
      {% set vars = [] %}
      {% for line in (env_example_content.content | b64decode).splitlines() %}
        {% if '=' in line and not line.strip().startswith('#') %}
          {% set parts = line.split('=', 1) %}
          {% set _ = vars.append({'name': parts[0].strip(), 'default': parts[1].strip(), 'comment': ''}) %}
        {% endif %}
      {% endfor %}
      {{ vars }}
  when: env_example_content.content is defined

- name: Read existing .env file content
  ansible.builtin.slurp:
    src: "/home/{{ app_user }}/app/.env"
  register: existing_env_file_content
  when:
    - env_example_file.stat.exists
    - env_vars_to_prompt is defined and env_vars_to_prompt | length > 0
    - ansible_check_mode is not defined or not ansible_check_mode # Only read if not in check mode
  become: yes
  become_user: "{{ app_user }}"
  ignore_errors: yes # File might not exist yet

- name: Initialize existing .env values
  ansible.builtin.set_fact:
    existing_env_values: {}

- name: Create dictionary from existing .env file
  ansible.builtin.set_fact:
    existing_env_values: |
      {% set result = {} %}
      {% if existing_env_file_content.content is defined %}
        {% for line in (existing_env_file_content.content | b64decode).splitlines() %}
          {% if '=' in line %}
            {% set parts = line.split('=', 1) %}
            {% set _ = result.update({parts[0].strip(): parts[1].strip()}) %}
          {% endif %}
        {% endfor %}
      {% endif %}
      {{ result }}
  when: existing_env_file_content.content is defined and existing_env_file_content.content | length > 0

- name: Determine effective defaults for .env variables
  ansible.builtin.set_fact:
    env_vars_processed: |
      {% set processed = [] %}
      {% set existing_dict = existing_env_values if existing_env_values is mapping else existing_env_values | default('{}') | from_yaml %}
      {% for item in env_vars_to_prompt | from_yaml %}
        {% set default_source = "" %}
        {% set temp_value = existing_dict[item.name] if item.name in existing_dict else item.default %}
        
        {% if item.name in existing_dict %}
            {% set default_source = "from existing .env" %}
        {% elif item.default %}
            {% set default_source = "from .env.example" %}
        {% endif %}
        
        {% if not temp_value and ('PASSWORD' in item.name or 'SECRET' in item.name) %}
           {% set final_value = lookup('password', '/dev/null length=32 chars=ascii_letters,digits') %}
           {% set default_source = "auto-generated" %}
        {% else %}
           {% set final_value = temp_value %}
        {% endif %}

        {% set _ = processed.append({
          'name': item.name,
          'comment': item.comment,
          'effective_default': final_value,
          'default_source': default_source
        }) %}
      {% endfor %}
      {{ processed }}
  when: env_vars_to_prompt is defined and env_vars_to_prompt | length > 0

- name: Prompt for .env variables
  ansible.builtin.pause:
    prompt: |
      {% if item.comment %}
      {{ item.comment }}
      {% endif %}
      Enter value for {{ item.name }}
      (Press Enter to accept: {{ item.effective_default }} ({{ item.default_source }}))
    # echo: no (removed to enable echoing of input)
  loop: "{{ env_vars_processed | from_yaml }}"
  loop_control:
    loop_var: item
  register: prompt_results
  when: env_vars_processed is defined and env_vars_processed | length > 0 and not ansible_check_mode

- name: Process prompted .env values
  ansible.builtin.set_fact:
    user_env_inputs_processed: |
      {% set inputs = {} %}
      {% for res in prompt_results.results %}
        {% set val = res.user_input if res.user_input | length > 0 else res.item.effective_default %}
        {% set _ = inputs.update({res.item.name: val}) %}
      {% endfor %}
      {{ inputs }}
  when: prompt_results.results is defined

- name: Write .env file
  ansible.builtin.copy:
    content: |
      {% for key, value in (user_env_inputs_processed | from_yaml).items() %}
      {{ key }}={{ value }}
      {% endfor %}
    dest: "/home/{{ app_user }}/app/.env"
    owner: "{{ app_user }}"
    group: "{{ app_user }}"
    mode: '0600'
  when: user_env_inputs_processed is defined and user_env_inputs_processed | length > 0
  become: yes
  become_user: "{{ app_user }}"

- name: Check for docker-compose.yml
  ansible.builtin.stat:
    path: "/home/{{ app_user }}/app/docker-compose.yml"
  register: docker_compose_file

- name: Fail if docker-compose.yml not found
  ansible.builtin.fail:
    msg: "docker-compose.yml not found in the repository"
  when: not docker_compose_file.stat.exists

  become: yes
  become_user: "{{ app_user }}"

- name: Start application with Docker Compose (Background)
  ansible.builtin.shell:
    cmd: "/home/{{ app_user }}/bin/docker compose up --build --wait > /home/{{ app_user }}/app/deploy.log 2>&1"
    chdir: "/home/{{ app_user }}/app"
  become: yes
  become_user: "{{ app_user }}"
  environment: "{{
    {'DOCKER_HOST': 'unix:///run/user/' + app_user_uid.stdout + '/docker.sock', 'PATH': '/home/' + app_user + '/bin:' + ansible_env.PATH}
    | combine(found_ports | default({}))
    | combine(user_env_inputs_processed | default('{}') | from_yaml)
    }}"
  async: 1800 # 30 minutes timeout
  poll: 0
  register: docker_deploy

- name: "Manual Log Monitoring Instruction"
  ansible.builtin.debug:
    msg:
      - "Docker deployment started in background (Job ID: {{ docker_deploy.ansible_job_id }})."
      - "To view the live build logs, SSH onto the remote machine and run:"
      - "sudo -u {{ app_user }} tail -f /home/{{ app_user }}/app/deploy.log"

- name: Wait for Docker deployment to complete
  ansible.builtin.async_status:
    jid: "{{ docker_deploy.ansible_job_id }}"
  register: job_result
  until: job_result.finished
  retries: 180 # 180 * 10s = 30 minutes
  delay: 10
  become: yes
  become_user: "{{ app_user }}"

- name: Create Nginx site configuration
  ansible.builtin.template:
    src: nginx.conf.j2
    dest: "/etc/nginx/sites-available/{{ app_domain_name }}"
  notify: restart nginx

- name: Enable Nginx site
  ansible.builtin.file:
    src: "/etc/nginx/sites-available/{{ app_domain_name }}"
    dest: "/etc/nginx/sites-enabled/{{ app_domain_name }}"
    state: link
  notify: restart nginx
