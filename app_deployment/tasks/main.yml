---
# tasks file for app_deployment
- name: Validate that APP_PORT is defined in app_ports
  ansible.builtin.fail:
    msg: "The 'app_ports' list in app_deployment/vars/main.yml must contain 'APP_PORT' for Nginx configuration."
  when: "'APP_PORT' not in app_ports"

- name: Set app_user fact
  ansible.builtin.set_fact:
    app_user: "{{ app_repo | basename | regex_replace('.git$', '') }}"

- name: Create a new system user for the application
  ansible.builtin.user:
    name: "{{ app_user }}"
    shell: /usr/sbin/nologin
    system: yes
    create_home: yes

- name: Get app_user uid
  ansible.builtin.command:
    cmd: "id -u {{ app_user }}"
  register: app_user_uid
  changed_when: false

- name: Download rootless docker install script
  ansible.builtin.get_url:
    url: https://get.docker.com/rootless
    dest: "/home/{{ app_user }}/get-docker-rootless.sh"
    mode: '0755'
  become: yes
  become_user: "{{ app_user }}"

- name: Install rootless docker
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/get-docker-rootless.sh"
  become: yes
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ app_user_uid.stdout }}"

- name: Add Docker bin to PATH
  ansible.builtin.lineinfile:
    path: "/home/{{ app_user }}/.bashrc"
    line: "export PATH=/home/{{ app_user }}/bin:$PATH"
    create: yes
  become: yes
  become_user: "{{ app_user }}"

- name: Add DOCKER_HOST to environment
  ansible.builtin.lineinfile:
    path: "/home/{{ app_user }}/.bashrc"
    line: "export DOCKER_HOST=unix:///run/user/{{ app_user_uid.stdout }}/docker.sock"
    create: yes
  become: yes
  become_user: "{{ app_user }}"

- name: Enable user lingering for app_user
  ansible.builtin.command:
    cmd: "loginctl enable-linger {{ app_user }}"

- name: Start rootless docker service for app_user
  ansible.builtin.systemd:
    scope: user
    name: docker
    enabled: yes
    state: started
  become: yes
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ app_user_uid.stdout }}"

- name: Find available ports for the application
  ansible.builtin.shell: |
    comm -23 <(seq 8080 8180 | sort) <(ss -Htan | awk '{print $4}' | awk -F':' '{print $NF}' | sort -u) | head -n {{ app_ports | length }}
  register: next_available_ports
  changed_when: false

- name: Create a dictionary of found ports
  ansible.builtin.set_fact:
    found_ports: "{{ dict(app_ports | zip(next_available_ports.stdout_lines)) }}"

- name: Set app_port fact for Nginx
  ansible.builtin.set_fact:
    app_port: "{{ found_ports.APP_PORT }}"

- name: Display assigned ports
  ansible.builtin.debug:
    msg: |
      Application ports have been assigned as follows:
      {% for port_name, host_port in found_ports.items() %}
      Service {{ port_name | replace('_PORT', '') | lower | capitalize }} ({{ port_name }}) is accessible via VPN at {{ ansible_host }}:{{ host_port }}
      {% endfor %}

- name: Read apps.json
  ansible.builtin.slurp:
    src: /var/www/status/apps.json
  register: apps_json_content

- name: Update apps.json
  ansible.builtin.copy:
    content: "{{ apps_json_content.content | b64decode | from_json | combine({app_user: found_ports}) | to_json }}"
    dest: /var/www/status/apps.json
  when: apps_json_content.content is defined

- name: Create app directory
  ansible.builtin.file:
    path: "/home/{{ app_user }}/app"
    state: directory
    owner: "{{ app_user }}"
    group: "{{ app_user }}"
    mode: '0755'

- name: Clone the application repository
  ansible.builtin.git:
    repo: "{{ app_repo }}"
    dest: "/home/{{ app_user }}/app"
    version: master
    accept_hostkey: yes
  become: yes
  become_user: "{{ app_user }}"

- name: Check for .env.example
  ansible.builtin.stat:
    path: "/home/{{ app_user }}/app/.env.example"
  register: env_example_file
  become: yes
  become_user: "{{ app_user }}"

- name: Read .env.example content
  ansible.builtin.slurp:
    src: "/home/{{ app_user }}/app/.env.example"
  register: env_example_content
  when: env_example_file.stat.exists
  become: yes
  become_user: "{{ app_user }}"

- name: Extract variable names from .env.example
  ansible.builtin.set_fact:
    env_vars_to_prompt: "{{ env_example_content.content | b64decode | splitlines | select('match', '^[A-Z_]+ *=') | map('split', '=') | map(attribute=0) | list }}"
  when: env_example_file.stat.exists and env_example_content.content is defined

- name: Read existing .env file content
  ansible.builtin.slurp:
    src: "/home/{{ app_user }}/app/.env"
  register: existing_env_file_content
  when:
    - env_example_file.stat.exists
    - env_vars_to_prompt is defined and env_vars_to_prompt | length > 0
    - ansible_check_mode is not defined or not ansible_check_mode # Only read if not in check mode
  become: yes
  become_user: "{{ app_user }}"
  ignore_errors: yes # File might not exist yet

- name: Parse existing .env file into dictionary
  ansible.builtin.set_fact:
    existing_env_values: "{{ existing_env_file_content.content | b64decode | from_ini }}"
  when: existing_env_file_content.content is defined and existing_env_file_content.content | length > 0

- name: Prompt for .env variables, reusing existing values
  ansible.builtin.set_fact:
    user_env_inputs_processed: "{{ user_env_inputs_processed | default({}) | combine({item: (ansible.builtin.prompt(name=item, prompt='Enter value for %s (current: %s - press Enter to keep)' | format(item, existing_env_values[item] | default('')), default=existing_env_values[item] | default(''), private=yes))}) }}"
  loop: "{{ env_vars_to_prompt }}"
  vars:
    existing_env_values: "{{ existing_env_values | default({}) }}" # Ensure it's always a dict
  when: env_vars_to_prompt is defined and env_vars_to_prompt | length > 0 and not ansible_check_mode

- name: Create .env file content from prompts
  ansible.builtin.set_fact:
    env_file_lines: "{{ env_file_lines | default([]) + ['%s=%s' | format(item.key, item.value)] }}"
  loop: "{{ user_env_inputs_processed | dict2items }}"
  when: user_env_inputs_processed is defined and user_env_inputs_processed | length > 0

- name: Write .env file
  ansible.builtin.copy:
    content: "{{ env_file_lines | join('\\n') }}"
    dest: "/home/{{ app_user }}/app/.env"
    owner: "{{ app_user }}"
    group: "{{ app_user }}"
    mode: '0600'
  when: env_file_lines is defined and env_file_lines | length > 0
  become: yes
  become_user: "{{ app_user }}"

- name: Check for docker-compose.yml
  ansible.builtin.stat:
    path: "/home/{{ app_user }}/app/docker-compose.yml"
  register: docker_compose_file

- name: Fail if docker-compose.yml not found
  ansible.builtin.fail:
    msg: "docker-compose.yml not found in the repository"
  when: not docker_compose_file.stat.exists

- name: Run docker-compose
  ansible.builtin.command:
    cmd: "/home/{{ app_user }}/bin/docker-compose up -d --build"
    chdir: "/home/{{ app_user }}/app"
  become: yes
  become_user: "{{ app_user }}"
  environment: "{{ {'DOCKER_HOST': 'unix:///run/user/{{ app_user_uid.stdout }}/docker.sock'} | combine(found_ports) }}"

- name: Create Nginx site configuration
  ansible.builtin.template:
    src: nginx.conf.j2
    dest: "/etc/nginx/sites-available/{{ app_domain_name }}"
  notify: restart nginx

- name: Enable Nginx site
  ansible.builtin.file:
    src: "/etc/nginx/sites-available/{{ app_domain_name }}"
    dest: "/etc/nginx/sites-enabled/{{ app_domain_name }}"
    state: link
  notify: restart nginx
